<!DOCTYPE html>
<head>
<title>
TiDB Read Duration
</title>
<link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/zyguan/railroad-diagrams@5e868a958ba52847e28b2adefc5dcd8b3172c58d/railroad.css'/>
<style>
  body {
    background-color: hsl(30, 20%, 95%);
  }
  svg.railroad-diagram rect {
    fill: rgb(245, 245, 245);
  }
  svg.railroad-diagram g.color-green rect {
    fill: rgb(204, 255, 204);
  }
  svg.railroad-diagram g.color-yellow rect {
    fill: rgb(254, 255, 204);
  }
  svg.railroad-diagram g.color-blue rect {
    fill: rgb(202, 220, 250);
  }
  *:target {
    background-color: rgb(247, 226, 198);
  }
  code, pre {
    background-color: #dddddd;
    border-radius: 0.25em;
    padding: 0 0.25em;
  }
  pre {
    padding: 0.25em;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/zyguan/railroad-diagrams@5e868a958ba52847e28b2adefc5dcd8b3172c58d/railroad.umd.js"></script>
</head>
<body>

<div id="railroad-tooltip" class="railroad-diagram-tooltip"></div>
<div id="CONTENT"></div>
<script id="MARKDOWN" type="text/plain">
# TiDB Read Duration

TiDB read by calling `Next` on cascade executors. So here we dig into the data source executors which actually cause the latency.

## Point get

```railroad
Diagram(
  Choice(
    0,
    Span("Resolve TSO", {href: "tidb-kv-client#resolve-tso"}),
    Comment("Read by clustered PK in auto-commit-txn mode"),
  ),
  Choice(
    0,
    Span("Read handle by index key", {color: "green", href: "tidb-snapshot-read#get", tooltip: "tidb_tikvclient_txn_cmd_duration_seconds{type=\"get\"}"}),
    Comment("Read by clustered PK, encode handle by key"),
  ),
  Span("Read value by handle", {color: "green", href: "tidb-snapshot-read#get", tooltip: "tidb_tikvclient_txn_cmd_duration_seconds{type=\"get\"}"}),
)
```

## Batch Point get

```railroad
Diagram(
  Span("Resolve TSO", {href: "tidb-kv-client#resolve-tso"}),
  Choice(
    0,
    Span("Read all handles by index keys", {color: "green", href: "tidb-snapshot-read#batchget", tooltip: "tidb_tikvclient_txn_cmd_duration_seconds{type=\"batch_get\"}"}),
    Comment("Read by clustered PK, encode handle by keys"),
  ),
  Span("Read values by handles", {color: "green", href: "tidb-snapshot-read#batchget", tooltip: "tidb_tikvclient_txn_cmd_duration_seconds{type=\"batch_get\"}"}),
)
```

Similar with point get, but batch point get has no change to skip resolving timestamp.

## Table Scan & Index Scan

```railroad
Diagram(
  Stack(
    Span("Resolve TSO", {href: "tidb-kv-client#resolve-tso"}),
    Span("Load region cache for related table/index ranges"),
    OneOrMore(
      Sequence(
        Span("Wait for result", {color: "green", href: "tidb-snapshot-read#coprocessor-scan", tooltip: "tidb_distsql_handle_query_duration_seconds_bucket{sql_type=\"general\"}"}),
      ),
      Comment("Next loop: drain the result")
    ),
  )
)
```

Table scan and index scan almost share the same code path.
For table scan, TiDB split part of the ranges as an optional signed ranges, but here we skip it.

## IndexLookUp

```railroad
Diagram(
  Stack(
    Span("Resolve TSO", {href: "tidb-kv-client#resolve-tso"}),
    Span("Load region cache for related index ranges"),
    OneOrMore(
      Sequence(
        Span("Wait for index scan result", {color: "green", href: "tidb-snapshot-read#coprocessor-scan", tooltip: "tidb_distsql_handle_query_duration_seconds_bucket{sql_type=\"general\"}"}),
        Span("Wait for table scan result", {color: "green", href: "tidb-snapshot-read#coprocessor-scan", tooltip: "tidb_distsql_handle_query_duration_seconds_bucket{sql_type=\"general\"}"}),
      ),
      Comment("Next loop: drain the result")
    ),
  )
)
```

Note if the index/table scan both are fast enough, they can be ready before we call `Next`, then wait will not take any time.
</script>

<script>
  // export railroad defaults
  Object.entries(railroad.default).forEach(([k, v]) => globalThis[k] = v);
  // aliases
  function Span(text, {href, tooltip, color}={}) {
    return NonTerminal(text, {href: href, tooltip: tooltip, cls: `color-${color}`})
  }

  // render markdown
  class Renderer extends marked.Renderer {
    constructor(options) {
      super(options);
      this.postActions = [];
    }
    code(text, lang, escaped) {
      if (lang != 'railroad') {
        return super.code(text, lang, escaped);
      } else {
        const id = `railroad-${window.crypto.getRandomValues(new Uint32Array(1))[0].toString(16)}`;
        this.postActions.push(function() {
          const src = document.createElement('script');
          src.innerHTML = `${text}.addTo(document.getElementById('${id}'), {tooltip: document.getElementById('railroad-tooltip')})`;
          document.body.appendChild(src);
        });
        return `<div id=${id}></div>\n`;
      }
    }
  }

  marked.setOptions({ renderer: new Renderer() });
  document.getElementById('CONTENT').innerHTML = marked.parse(document.getElementById('MARKDOWN').innerText);
  marked.defaults.renderer.postActions.forEach(fn => fn());


  // quick copy tooltip to clipboard
  let tooltipElement = document.getElementById("railroad-tooltip");
  for (const span of document.querySelectorAll('.non-terminal')) {
    span.addEventListener("click", () => {
      // skip spans without tooltip
      if (tooltipElement.style.display !== 'block') {
        return;
      }
      navigator.clipboard.writeText(tooltipElement.innerText).then(() => {
        alert("Copy tooltip to clipboard");
      });
    }) 
  }
</script>

</body>
